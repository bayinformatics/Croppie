function R(V,G){let J=document.createElement(V);if(G?.className)J.className=G.className;if(G?.attributes)for(let[K,N]of Object.entries(G.attributes))J.setAttribute(K,N);if(G?.styles)Object.assign(J.style,G.styles);return J}function P(V,G,J,K){V.style.transform=`translate(${G}px, ${J}px) scale(${K})`}function U(V){return R("div",{className:`croppie-container${V?` ${V}`:""}`})}function j(V){return R("div",{className:"cr-boundary",styles:{width:`${V.width}px`,height:`${V.height}px`,position:"relative",overflow:"hidden"}})}function T(V){return R("div",{className:`cr-viewport cr-vp-${V.type}`,styles:{width:`${V.width}px`,height:`${V.height}px`,position:"absolute",top:"50%",left:"50%",transform:"translate(-50%, -50%)",pointerEvents:"none",borderRadius:V.type==="circle"?"50%":"0"}})}function X(V,G){let J=R("div",{className:"cr-overlay",styles:{position:"absolute",top:"0",left:"0",width:"100%",height:"100%",pointerEvents:"none"}}),K=g(V,G);return J.style.background="rgba(0, 0, 0, 0.5)",J.style.maskImage=K,J.style.webkitMaskImage=K,J}function g(V,G){let J=V.width/2,K=V.height/2;if(G.type==="circle"){let A=G.width/2;return`radial-gradient(circle ${A}px at ${J}px ${K}px, transparent ${A}px, black ${A}px)`}let N=J-G.width/2,Q=J+G.width/2,$=K-G.height/2,B=K+G.height/2;return`
    linear-gradient(to right, black ${N}px, transparent ${N}px, transparent ${Q}px, black ${Q}px),
    linear-gradient(to bottom, black ${$}px, transparent ${$}px, transparent ${B}px, black ${B}px)
  `}function Y(){return R("img",{className:"cr-image",attributes:{alt:"Cropper image",draggable:"false"},styles:{position:"absolute",top:"0",left:"0",transformOrigin:"0 0",maxWidth:"none",maxHeight:"none"}})}function D(V,G,J){return R("input",{className:"cr-slider",attributes:{type:"range",min:String(V),max:String(G),step:"0.01",value:String(J)}})}function E(){return R("div",{className:"cr-slider-wrap"})}function k(V,G,J,K,N){let Q=document.createElement("canvas");Q.width=J,Q.height=K;let $=Q.getContext("2d");if(!$)throw Error("Failed to get 2D context");if(N?.backgroundColor)$.fillStyle=N.backgroundColor,$.fillRect(0,0,J,K);if(N?.circle)$.beginPath(),$.arc(J/2,K/2,J/2,0,Math.PI*2),$.closePath(),$.clip();let B=G.bottomRightX-G.topLeftX,A=G.bottomRightY-G.topLeftY;return $.drawImage(V,G.topLeftX,G.topLeftY,B,A,0,0,J,K),Q}function z(V,G="png",J=0.92){return new Promise((K,N)=>{let Q=`image/${G}`;V.toBlob(($)=>{if($)K($);else N(Error("Failed to create blob from canvas"))},Q,J)})}function C(V,G="png",J=0.92){let K=`image/${G}`;return V.toDataURL(K,J)}function f(V,G,J,K){let N={isDragging:!1,startX:0,startY:0,startTransformX:0,startTransformY:0},Q=(A)=>{if(A.button!==0)return;N.isDragging=!0,N.startX=A.clientX,N.startY=A.clientY;let _=G();N.startTransformX=_.x,N.startTransformY=_.y,V.setPointerCapture(A.pointerId),V.style.cursor="grabbing",K?.onStart?.(_)},$=(A)=>{if(!N.isDragging)return;let _=A.clientX-N.startX,I=A.clientY-N.startY,F=N.startTransformX+_,S=N.startTransformY+I;J(F,S);let M=G();K?.onMove?.(M)},B=(A)=>{if(!N.isDragging)return;N.isDragging=!1,V.releasePointerCapture(A.pointerId),V.style.cursor="grab";let _=G();K?.onEnd?.(_)};return V.addEventListener("pointerdown",Q),V.addEventListener("pointermove",$),V.addEventListener("pointerup",B),V.addEventListener("pointercancel",B),V.style.cursor="grab",V.style.touchAction="none",()=>{V.removeEventListener("pointerdown",Q),V.removeEventListener("pointermove",$),V.removeEventListener("pointerup",B),V.removeEventListener("pointercancel",B)}}function q(V,G,J){return Math.min(Math.max(V,G),J)}function Z(V,G,J,K,N,Q=!1){let $=(B)=>{if(Q&&!B.ctrlKey)return;B.preventDefault();let A=G(),_=B.deltaY>0?-0.1:0.1,I=q(A+_,K.min,K.max);if(I!==A)J(I),N?.onChange?.(I,A)};return V.addEventListener("wheel",$,{passive:!1}),()=>{V.removeEventListener("wheel",$)}}function w(V,G,J,K,N){let Q=0,$=1,B=(F)=>{if(F.length<2)return 0;let S=F.item(0),M=F.item(1);if(!S||!M)return 0;let x=S.clientX-M.clientX,O=S.clientY-M.clientY;return Math.sqrt(x*x+O*O)},A=(F)=>{if(F.touches.length===2)F.preventDefault(),Q=B(F.touches),$=G()},_=(F)=>{if(F.touches.length===2&&Q>0){F.preventDefault();let M=B(F.touches)/Q,x=G(),O=q($*M,K.min,K.max);if(O!==x)J(O),N?.onChange?.(O,x)}},I=()=>{Q=0};return V.addEventListener("touchstart",A,{passive:!1}),V.addEventListener("touchmove",_,{passive:!1}),V.addEventListener("touchend",I),()=>{V.removeEventListener("touchstart",A),V.removeEventListener("touchmove",_),V.removeEventListener("touchend",I)}}function y(V){return new Promise((G,J)=>{let K=new Image;if(!V.startsWith("data:"))K.crossOrigin="anonymous";K.onload=()=>G(K),K.onerror=()=>J(Error(`Failed to load image: ${V}`)),K.src=V})}function H(V){return new Promise((G,J)=>{let K=new FileReader;K.onload=()=>{if(typeof K.result==="string")G(K.result);else J(Error("Failed to read file as data URL"))},K.onerror=()=>J(Error("Failed to read file")),K.readAsDataURL(V)})}function L(V,G,J,K){let N=J/V,Q=K/G;return Math.max(N,Q)}function W(V){if(V===void 0)return;if(Array.isArray(V)){if(V.length!==4)throw Error("PointsArray must have exactly 4 elements: [topLeftX, topLeftY, bottomRightX, bottomRightY]");return{topLeftX:V[0],topLeftY:V[1],bottomRightX:V[2],bottomRightY:V[3]}}return V}var v={min:0.1,max:10};class b{element;options;container=null;boundaryEl=null;viewportEl=null;overlayEl=null;previewEl=null;sliderEl=null;image=null;transform={x:0,y:0,scale:1};zoomConfig;effectiveMinZoom=0.1;eventHandlers=new Map;cleanupFns=[];constructor(V,G){this.element=V;let J={width:G.viewport.width+100,height:G.viewport.height+100};if(this.options={...G,boundary:G.boundary??J,showZoomer:G.showZoomer??!0,mouseWheelZoom:G.mouseWheelZoom??!0},this.zoomConfig={...v,...G.zoom},G.enableOrientation!==void 0)console.warn("[@bayinformatics/croppie] enableOrientation is deprecated and has no effect. Rotation support is planned for a future release.");this.createElements(),this.attachEventHandlers()}createElements(){if(this.container=U(this.options.customClass),this.boundaryEl=j(this.options.boundary),this.viewportEl=T(this.options.viewport),this.overlayEl=X(this.options.boundary,this.options.viewport),this.previewEl=Y(),this.boundaryEl.appendChild(this.previewEl),this.boundaryEl.appendChild(this.overlayEl),this.boundaryEl.appendChild(this.viewportEl),this.container.appendChild(this.boundaryEl),this.options.showZoomer){let V=E();this.sliderEl=D(this.zoomConfig.min,this.zoomConfig.max,this.transform.scale),V.appendChild(this.sliderEl),this.container.appendChild(V);let G=()=>{if(this.sliderEl){let J=this.transform.scale;this.setZoom(Number.parseFloat(this.sliderEl.value)),this.emitEvent("zoom",{zoom:this.transform.scale,previousZoom:J})}};this.sliderEl.addEventListener("input",G),this.cleanupFns.push(()=>{this.sliderEl?.removeEventListener("input",G)})}this.element.appendChild(this.container)}attachEventHandlers(){if(!this.boundaryEl||!this.previewEl)return;let V=f(this.boundaryEl,()=>this.transform,(J,K)=>{this.transform.x=J,this.transform.y=K,this.updateTransform(),this.emitUpdate()});if(this.cleanupFns.push(V),this.options.mouseWheelZoom){let J=this.options.mouseWheelZoom==="ctrl",K=Z(this.boundaryEl,()=>this.transform.scale,(N)=>this.setZoom(N),this.zoomConfig,{onChange:(N,Q)=>{this.emitEvent("zoom",{zoom:N,previousZoom:Q})}},J);this.cleanupFns.push(K)}let G=w(this.boundaryEl,()=>this.transform.scale,(J)=>this.setZoom(J),this.zoomConfig,{onChange:(J,K)=>{this.emitEvent("zoom",{zoom:J,previousZoom:K})}});this.cleanupFns.push(G)}async bind(V){let G=typeof V==="string"?{url:V}:V;if(this.image=await y(G.url),this.previewEl)this.previewEl.src=this.image.src;let J=L(this.image.naturalWidth,this.image.naturalHeight,this.options.viewport.width,this.options.viewport.height);if(this.zoomConfig.enforceMinimumCoverage!==!1)this.effectiveMinZoom=Math.max(this.zoomConfig.min,J);else this.effectiveMinZoom=this.zoomConfig.min;let K=G.zoom??J;if(this.transform={x:0,y:0,scale:q(K,this.effectiveMinZoom,this.zoomConfig.max)},this.sliderEl)this.sliderEl.min=String(this.effectiveMinZoom);if(G.points){let N=W(G.points);if(N)console.warn("[@bayinformatics/croppie] Initial points are not yet fully supported. Provided:",N)}this.updateTransform(),this.updateSlider()}async bindFile(V){let G=await H(V);await this.bind({url:G})}async result(V){if(!this.image)throw Error("No image bound");let G=this.getPoints(),J=this.options.viewport,K,N;if(V.size==="viewport")K=J.width,N=J.height;else if(V.size==="original")K=G.bottomRightX-G.topLeftX,N=G.bottomRightY-G.topLeftY;else if(V.size)K=V.size.width,N=V.size.height;else K=J.width,N=J.height;let Q=k(this.image,G,K,N,{circle:V.circle??J.type==="circle",backgroundColor:V.backgroundColor});switch(V.type){case"canvas":return Q;case"base64":return C(Q,V.format,V.quality);case"blob":return z(Q,V.format,V.quality);default:throw Error(`Unknown result type: ${V.type}`)}}get(){return{points:this.getPoints(),zoom:this.transform.scale}}get zoom(){return this.transform.scale}set zoom(V){this.setZoom(V)}setZoom(V){let G=this.transform.scale;if(this.transform.scale=q(V,this.effectiveMinZoom,this.zoomConfig.max),this.updateTransform(),this.updateSlider(),G!==this.transform.scale)this.emitUpdate()}rotate(V){console.warn("Rotation not yet implemented:",V)}reset(){if(this.image){let V=L(this.image.naturalWidth,this.image.naturalHeight,this.options.viewport.width,this.options.viewport.height),G=q(V,this.effectiveMinZoom,this.zoomConfig.max);this.transform={x:0,y:0,scale:G},this.updateTransform(),this.updateSlider(),this.emitUpdate()}}destroy(){for(let V of this.cleanupFns)V();if(this.cleanupFns=[],this.eventHandlers.clear(),this.container?.parentNode)this.container.parentNode.removeChild(this.container);this.container=null,this.boundaryEl=null,this.viewportEl=null,this.overlayEl=null,this.previewEl=null,this.sliderEl=null,this.image=null}on(V,G){if(!this.eventHandlers.has(V))this.eventHandlers.set(V,new Set);this.eventHandlers.get(V)?.add(G)}off(V,G){this.eventHandlers.get(V)?.delete(G)}updateTransform(){if(this.previewEl){let V=this.options.boundary.width,G=this.options.boundary.height,J=this.image?.naturalWidth??0,K=this.image?.naturalHeight??0,N=J*this.transform.scale,Q=K*this.transform.scale,$=(V-N)/2+this.transform.x,B=(G-Q)/2+this.transform.y;P(this.previewEl,$,B,this.transform.scale)}}updateSlider(){if(this.sliderEl)this.sliderEl.value=String(this.transform.scale)}getPoints(){if(!this.image)return{topLeftX:0,topLeftY:0,bottomRightX:0,bottomRightY:0};let V=this.options.viewport,G=this.options.boundary,J=this.image.naturalWidth,K=this.image.naturalHeight,N=J*this.transform.scale,Q=K*this.transform.scale,$=(G.width-N)/2+this.transform.x,B=(G.height-Q)/2+this.transform.y,A=(G.width-V.width)/2,_=(G.height-V.height)/2,I=(A-$)/this.transform.scale,F=(_-B)/this.transform.scale,S=I+V.width/this.transform.scale,M=F+V.height/this.transform.scale;return{topLeftX:Math.max(0,I),topLeftY:Math.max(0,F),bottomRightX:Math.min(J,S),bottomRightY:Math.min(K,M)}}emitUpdate(){this.emitEvent("update",this.get())}emitEvent(V,G){let J=this.eventHandlers.get(V);if(J)for(let K of J)K(G)}}export{b as default,b as Croppie};

//# debugId=8AA6028A65FE1D2C64756E2164756E21
//# sourceMappingURL=croppie.js.map
